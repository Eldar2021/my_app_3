/*
Flutter Navigator 2.0'ı Anlamak
    Bu Flutter Navigator 2.0 öğreticisi, Dart ve Flutter hakkında çalışma 
    bilgisine sahip olduğunuzu varsayar.

Navigasyon, mobil uygulama geliştirmede temel bir kavramdır. Kullanıcıların bir
ekrandan diğerine geçmesini sağlar. İyi yönetilen gezinme, uygulamanızı düzenli 
tutar ve yeteneklerini geliştirir.

Flutter offers an imperative API (Navigator 1.0) and a declarative API 
(Navigator 2.0)routing mechanism. In Navigator 1.0, you can only add a page 
to the top of the navigation stack and remove the topmost route. On the other 
hand, the declarative mechanism allows you to control the navigation stack 
completely.

Navigator — быстрый старт

    Когда в проекте мы дошли до создания навигации, то задали себе вопросы:
    Какие есть для этого возможности во Flutter?
    Какой подход выбрать?
    Какие есть подводные камни у разных вариантов?
    Нужен ли нам Navigator 2.0?
    Как все эти подходы соотносятся с нашими бизнес-требованиями?

Естественно, мы вспомнили про Navigator — самое доступное решение во 
Flutter для навигации, с которым прежде всего знакомятся начинающие 
разработчики. Navigator — это stateful-виджет, создаваемый внутри 
MaterialApp/CupertinoApp. State данного виджета содержит текущий стек 
навигации и предоставляет методы для изменения этого состояния.

Простой переход на новую страницу выглядит следующим образом:

Navigator.push(
	context, 
	MaterialPageRoute(builder: (context) => SecondPage()),
);

В примере используется MaterialPageRoute, который реализует интерфейс Route. 
Эта сущность связывает Navigator и виджет страницы. Она определяет некоторые 
визуальные особенности страницы: анимацию появления и удаления, отображение 
на весь экран или в виде диалога, а также некоторые поведенческие 
особенности — например, за жест свайпа назад на iOS отвечает Route.

Кроме простого push, Navigator предоставляет обширный набор методов, 
которыми можно изменять стек навигации:


    push — добавление новой страницы

    pop — возврат назад (в том числе с возвратом значения)

    popUntil — возврат назад, пока не выполнится переданное условие

    pushReplacement — замена текущей страницы на другую

    pushAndRemoveUntil — добавление новой страницы и удаление из стека 
    навигации предыдущих страниц, пока не выполнится условие.

Можно ли расширить Navigator?
    Легко заметить, что все эти методы императивные: мы говорим навигатору, 
    как хотим изменить его состояние — добавить или удалить какой-то экран. 
    При этом остальной фреймворк использует декларативный API для построения 
    пользовательского интерфейса. Мы задаем некоторое дерево виджетов, на 
    основе которого всё отображается. Не хотим сказать, что императивный 
    подход для навигации — это плохо, наоборот, в этом нет ничего дурного —
    просто по-другому.

    Мы обращаем ваше внимание на иное — набор методов для навигации и их 
    поведение фиксированные: нельзя добавить свой метод или изменить реализацию 
    имеющегося. Значит Navigator нерасширяемый — это намного важнее того, что 
    он использует другой подход.

    Например, для реализации уже не нового, но популярного подхода к навигации 
    с bottom navigation bar придется сделать свою сущность, отвечающую за 
    смену табов. Эта сущность будет совсем отдельно от Navigator, таким образом 
    теряется единая точка входа в навигацию.

Знакомимся с Router (Navigator 2.0)

    Прошлой осенью разработчики Flutter выкатили новую версию компонента 
    навигации — Navigator 2.0, который позже переименовали в Router. 
    И это более правильное обозначение, так как Navigator 2.0 вносил путаницу. 
    Казалось, он предназначен, чтобы заменить первый Navigator, что первая 
    версия скоро станет deprecated и нужно срочно переезжать на новую       
    версию. Это не так, Router — альтернативный подход, имеющийся теперь у 
    разработчиков; он дает совершенно другие возможности.

Router — просто о сложном
    Все не так уж и сложно, как кажется на первый взгляд. В новом подходе 
    есть три основные сущности:

    Router   
    RouterDelegate
    RouteInformationParser

    Рассмотрим каждый из них. Router — виджет, который связывает RouterDelegate,
    RouteInformationParser и пользовательский интерфейс. Нам нужно реализовать 
    RouterDelegate. Он сообщает Router о том, что изменилось состояние 
    навигации. Когда это происходит, Router вызывает build у RouterDelegate, 
    и пользователь видит изменение состояния приложения, то
    есть открывается новый экран либо происходит переход назад.

    RouteInformationParser должен реализовывать два метода:

        parseRouteInformation — парсит ссылку и возвращает новое состояние 
        навигации (в случае изменения адреса в браузере 
        или перехода по deeplink);

        restoreRouteInformation — преобразовывает текущее состояние навигации 
        в ссылку, которая отображается в адресной строке браузера. Его 
        необязательно реализовывать в мобильном приложении.

Если кратко, что происходит в примере: у нас есть некоторый State навигации, 
состоящий из полей _selectedBook и show404. При нажатии на книгу изменяется 
значение _selectedBook; при переходе по deeplink происходит парсинг id книги 
и отображение нужной страницы либо 404.

https://blog.codemagic.io/flutter-navigator2/

https://habr.com/ru/company/rshb/blog/584348/



*/
